\documentclass{article}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[vietnamese]{babel}

\begin{document}

\section*{VQ4 FLOWERS}

\textbf{Solution:} \\

Sau khi nhập mảng, ta sắp xếp lại các giá trị trong phần tử theo thứ tự tăng dần.
Sau đó, ta dùng deque với định dạng pair để xử lí bài toán này, giá trị first để lưu giá trị của phần từ  và second để lưu số lần xuất hiện của phần tử đó. \\ \\
Với mảng ta đã sắp xếp thì ta nén số và push vào trong deque bằng cách như sau:

\begin{verbatim}
    sort(a + 1, a + n + 1);
    int j = 1;
    for(int i = 2; i <= n + 1; i++)
    {
        if(a[i] != a[i - 1]) q.push_back({a[i - 1], i - j}), j = i;
    }
\end{verbatim}
Lần lượt lấy phần tử front của deque rồi in ra màn hình, sau đó giảm số lần xuất hiện của phần tử đó xuống 1 đơn vị và push lại vào cuối deque (Nếu số lần xuất hiện bằng 0 thì ta bỏ qua bước push back). Ta làm liên tục cho đến khi đủ k phần tử cần tìm.


\section*{Point2D}
Xây dựng một cấu trúc bằng struct chứa hai biến x và y. \\
Viết hàm cmp để sort theo sự tăng dần của x và giảm dần của y. \\

\begin{verbatim}
         struct info{
            int x, y;
         };

         bool cmp(info A, info B)
         {
              if(A.x == B.x) return A.y > B.y;
              return A.x < B.x;
         }
\end{verbatim}

sort lại và in các phần tử theo thứ tự đã sắp xếp.

\section*{VS14 Gifts}

Nhập các phần tử vào mảng và sắp xếp theo thứ tự tăng dần. \\ 
với mỗi a[i] thì ta sẽ tìm phần tử bé hơn hoặc bằng phần từ k - a[i], để làm được điều đó một cách nhanh chóng thì ta sẽ chặt nhị phân để tìm phần tử ta cần.

\begin{verbatim}
                for(int i = 1; i <= n; i++)
                {
                    if(a[i] >= k) continue;
                    int p = bs(1, n + 1, k - a[i]);
                    if(p == -1) continue;
                    if(a[p] == a[i]) p--;
                    res = max(res, a[i] + a[p]);
                }
\end{verbatim}
Tham lam để lấy các trường hợp lớn nhất có thể xảy ra và lưu vào trong biến res.

\section*{Password Strength}

Nhập chuỗi và duyệt từng phần tử trong chuỗi, với mỗi kí tự ta duyệt thì sẽ tăng các biến tương ứng lưu lên 1 đơn vị. \\
sau khi đã có được số lượng thì ta kiểm tra các điều kiện để gán vào các hê số nhân. \\
Dùng công thức đã cho sẵn thì ta tính được điểm số của password. 

\begin{verbatim}
                    if(x == INT_MIN) cout << "KhongHopLe";
                    else if(x < 50) cout << "Yeu";
                    else if(50 <= x && x < 75) cout << "Vua";
                    else if(75 <= x && x < 100) cout << "Manh";
                    else cout << "RatManh";
\end{verbatim}


\section*{Caeser Cipher}

Nhập chuỗi và xử lí chuỗi như công thức đã đề cập sẵn với độ lệch là k phần tử\\

\begin{verbatim}
    for(int i = 0; i <= int(s.size()) - 1; i++)
    {
        if('A' <= s[i] && s[i] <= 'Z') cout << char(((s[i] + k - 'A')% 26) + 'A');
        else cout << s[i];
    }
\end{verbatim}

\section*{Reversing Encryption}

Nhập chuỗi và xử lí chuỗi bằng cách đảo kí tự từ 1 đến i (với i là ước của n), dưới đây là đoạn code xử lí chuỗi \\ \\

\begin{verbatim}
                int n = s.size();
                for(int i = 2; i <= n; i++)
                {
                    if(!(n % i)) reverse(s.begin(), s.begin() + i);
                }
    cout << s;
\end{verbatim}

\section*{Messages}
Nhập chuỗi s1 và s2, ta sẽ dùng for để duyệt từ min(s1.size, s2.size) đến 0 là độ dài của đoạn có thể trùng nhau
\begin{verbatim}
             for(int i = k; i >= 1; i--)
            {
                if(a.substr(a.size() - i, i) == b.substr(0, i))
                {
                    res = i;
                    break;
                }
            }
        
            string s = a + b.substr(res);
            cout << s.size() << '\n';
\end{verbatim}
duyệt đến khi có kết quả đầu tiên thì ta sẽ dừng vòng lập và đó cũng là độ dài đoạn trùng nhau lớn nhất mà ta cần tìm.

\section*{Binary Search 1}
Ta sẽ dùng chặt nhị phân để tìm vị trí phần tử cần tìm nếu tìm ra phần tử thì sẽ res sẽ lưu vị trí của phần tử đó, còn ngược lại thì res = -1 \\

\begin{verbatim}
                    int l = 1, r = n;
                    while(l <= r)
                    { 
                        cnt++;
                        int mid = (l + r) >> 1;
                        if(a[mid] < x) res = mid, l = mid + 1;
                        else if(a[mid] == x) res = mid, break;
                        else r = mid - 1;  
                    }

\end{verbatim}

\section*{Binary Search 2}
 Ta xem các kí tự dưới dạng số và làm tương tự như bài Binary Search 1

 \begin{verbatim}
                    int l = 1, r = n;    
                    while(l <= r)
                    {
                        cnt++;
                        int mid = (l + r) >> 1;
                        if(s[mid] < x) l = mid + 1;
                        else if(s[mid] == x) {
                            res = mid;
                            break;
                        }
                        else r = mid - 1;
                    }

\end{verbatim}


\section*{Linear Search 1}
Duyệt từ 1 đến n để tìm vị trí của phần tử cần tìm.

 \begin{verbatim}
                bool check = 0;
                for(int i = 0; i < n; i++)
                {
                    if(a[i] == x)
                    {
                        check = 1;
                        res = i;
                    }
                    
                    if(check) break;
                }
            
                if(check){
                    cout << res << '\n';
                    cout << res + 1 << '\n';
                    cout << n - res - 1 << '\n';
                    cout << n - res << '\n'; 
                }
                else cout << -1;
\end{verbatim}

\section*{Linear Search 2}
Duyệt từ 1 đến n để tìm vị trí của các phần tử cần tìm. Sau đó, bỏ lần lượt vào vector và xử lí. \\

 \begin{verbatim}
                for(int i = 0; i < n; i++)
                {
                    if(a[i] == x)
                    {
                        res.push_back(i);
                    }
                }
            
                if(res.size()){
                    cout << res.size() << '\n';
                    for(int i = 0; i <= int(res.size()) - 1; i++)
                    {
                        cout << res[i] << ' ' << res[i] + 1 << '\n';
                    }
                }
                else cout << 0;
\end{verbatim}

\section*{Linear Search 3}
Dùng map để cập nhật từng giá trị đã xuất hiện theo thứ tự đã cho.

 \begin{verbatim}
                int j = 0, x;
                for(int i = 1; i <= n; i++)
                {
                    cin >> x;
                    mp[x] = 1;
                    while(mp[j]) j++;
                    cout << j << ' ';
                }
\end{verbatim}

\section*{Linear Search 5}
Nhập các phần tử đã cho và sort lại theo thứ tự từ bé đến lớn. Sau đó ta lấy hiệu giá trị lớn nhất và bé nhất lưu vào biến res. Nếu số lượng phần tử lớn hơn 3 thì ta cộng thêm vào res hiệu giữa giá trị lớn nhì và bé nhì.

 \begin{verbatim}
                sort(a + 1, a + n + 1);
                int sum1 = a[n] - a[1];
                int sum2 = 0;
                if(n > 3) sum2 = a[n - 1] - a[2];
                cout << sum1 + sum2 << '\n';
\end{verbatim}

\section*{VW05p Enrichement}
Nhập mảng n x m đã cho, rồi ta dùng prefix sum để lưu tổng các ô trên mảng và truy suất tổng tất cả các ô có kích thước 3x3.\\ \\
Công thức truy suất như sau

 \begin{verbatim}
        int get(int x1, int y1, int x2, int y2, const vector<vector<int>> &a)
        {   
            return (a[x2][y2] - a[x2][y1 - 1] - a[x1 - 1][y2] + a[x1 - 1][y1 - 1]);
        }

\end{verbatim}

Lấy min các trường hợp có thể xảy ra.
 
\begin{verbatim}
             for(int i = 1; i + 2 <= n; i++)
            {
                for(int j = 1; j + 2 <= m; j++)
                {
                    res = min(res, (ll)get(i, j, i + 2, j + 2, a));
                }
            }
\end{verbatim}
\end{document}
